<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DASH Live Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Dash.js v4 (settings schema compatible with this file) -->
    <script defer src="https://cdn.dashjs.org/v4.7.1/dash.all.min.js"></script>
    <style>
      /* Hide seek bar and play/pause, keep volume/fullscreen */
      video::-webkit-media-controls-timeline,
      video::-webkit-media-controls-current-time-display,
      video::-webkit-media-controls-time-remaining-display,
      video::-webkit-media-controls-seek-back-button,
      video::-webkit-media-controls-seek-forward-button,
      video::-webkit-media-controls-play-button { display: none !important; }
      video::-moz-media-controls-timeline,
      video::-moz-media-controls-play-button { display: none !important; }

      /* nice 16:9 without plugin */
      .ar-16x9 { aspect-ratio: 16 / 9; }
    </style>
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100 antialiased selection:bg-sky-500/30">
    <div class="mx-auto max-w-6xl p-6 space-y-5">
      <!-- Header / status -->
      <header class="rounded-2xl border border-slate-800 bg-slate-900/60 px-5 py-4 shadow-sm">
        <div class="flex items-center justify-between gap-4">
          <h1 class="text-xl font-semibold tracking-tight">dash-transcoder • Live</h1>
          <span id="status" class="rounded-full border border-slate-800 bg-slate-800/70 px-3 py-1 text-xs text-slate-300">Booting…</span>
        </div>
        <div class="mt-2 flex flex-wrap items-center gap-x-3 gap-y-1 text-sm">
          <div class="text-slate-300">
            MPD:
            <code id="mpd-url" class="rounded bg-slate-800/80 px-1.5 py-0.5 text-slate-200">http://192.168.1.150:8080/out/audio_video.mpd</code>
          </div>
          <div id="stats" class="text-slate-400 text-xs"></div>
        </div>
      </header>

      <!-- Player card -->
      <main class="rounded-2xl border border-slate-800 bg-slate-900/40 p-3 shadow-sm">
        <div class="relative ar-16x9 overflow-hidden rounded-xl border border-slate-800 bg-black">
          <video
            id="dash-player"
            class="h-full w-full"
            controls
            autoplay
            muted
            playsinline
            preload="auto"
          ></video>

          <!-- OFFLINE overlay (centered text) -->
          <div
            id="offline-overlay"
            class="absolute inset-0 hidden items-center justify-center bg-black/95"
          >
            <div class="text-center">
              <div class="mx-auto mb-3 h-3 w-3">
                <span class="relative flex h-3 w-3">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-sky-400/70 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-3 w-3 bg-sky-300"></span>
                </span>
              </div>
              <p class="text-base font-semibold text-slate-200">Stream offline</p>
              <p class="mt-1 text-xs text-slate-400">Waiting for MPD…</p>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script>
      window.addEventListener('load', () => {
        // ?mpd=<url> override
        const qs = new URLSearchParams(location.search);
        const MPD_URL = qs.get('mpd') || 'http://192.168.1.150:8080/out/audio_video.mpd';
        document.getElementById('mpd-url').textContent = MPD_URL;

        // Elements
        const statusEl = document.getElementById('status');
        const statsEl  = document.getElementById('stats');
        const overlay  = document.getElementById('offline-overlay');
        let   video    = document.getElementById('dash-player');

        // dash.js player
        let player = null;

        // Polling state
        let polling = false;
        let pollTimer = null;
        let consecutiveOK = 0;

        const E = dashjs.MediaPlayer.events;

        // --- UI helpers ------------------------------------------------------
        const badgeClasses = {
          info: 'rounded-full border px-3 py-1 text-xs border-sky-800 bg-sky-900/40 text-sky-200',
          warn: 'rounded-full border px-3 py-1 text-xs border-amber-800 bg-amber-900/40 text-amber-200',
          ok:   'rounded-full border px-3 py-1 text-xs border-emerald-800 bg-emerald-900/40 text-emerald-200',
          err:  'rounded-full border px-3 py-1 text-xs border-rose-800 bg-rose-900/40 text-rose-200'
        };

        function setStatus(type, msg) {
          statusEl.className = badgeClasses[type] || badgeClasses.info;
          statusEl.innerHTML = msg;
        }

        const spinner = (text) => `
          <span class="relative -mt-0.5 mr-2 inline-flex h-3 w-3 align-middle">
            <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-current opacity-60"></span>
            <span class="relative inline-flex h-3 w-3 rounded-full bg-current"></span>
          </span>${text}`;

        function showOffline() {
          try {
            video.pause?.();
            video.removeAttribute('src');
            video.load?.();
          } catch {}
          overlay.classList.remove('hidden');
          setStatus('warn', spinner('Waiting for MPD (404)… Rechecking in 1s'));
        }

        function hideOffline() {
          overlay.classList.add('hidden');
        }

        async function headOrGet(url) {
          try {
            const r = await fetch(url, { method: 'HEAD', cache: 'no-store' });
            if (r.ok) return r;
            if (r.status === 405 || r.status === 501) {
              const g = await fetch(url, { method: 'GET', cache: 'no-store' });
              return g;
            }
            return r;
          } catch {
            return { ok: false, status: 0 };
          }
        }

        function cloneVideoElement() {
          const fresh = video.cloneNode(false);
          video.replaceWith(fresh);
          video = fresh;
          video.setAttribute('autoplay', '');
          video.setAttribute('muted', '');
          video.muted = true;
          video.playsInline = true;
          return video;
        }

        function createPlayer() {
          const p = dashjs.MediaPlayer().create();
          p.updateSettings({
            streaming: {
              lowLatencyEnabled: false,
              delay: {
                liveDelay: NaN,
                liveDelayFragmentCount: 3,
                useSuggestedPresentationDelay: true
              },
              liveCatchup: {
                enabled: true,
                maxDrift: 1.0,
                playbackRate: { min: -0.2, max: 0.2 }
              },
              buffer: {
                fastSwitchEnabled: false,
                bufferPruningInterval: 10,
                bufferToKeep: 6,
                bufferTimeAtTopQuality: 8,
                bufferTimeAtTopQualityLongForm: 8
              },
              text: { defaultEnabled: false }
            },
            abr: {
              limitBitrateByPortal: true,
              initialBitrate: { video: 2500, audio: 128 },
              autoSwitchBitrate: { video: true, audio: true }
            }
          });
          return p;
        }

        function teardownPlayer({ keepVideo = false } = {}) {
          try { player?.reset(); } catch {}
          player = null;
          try {
            video.pause?.();
            video.removeAttribute('src');
            video.load?.();
          } catch {}
          if (!keepVideo) cloneVideoElement();
          showOffline();
        }

        function initPlayer() {
          const src = MPD_URL + (MPD_URL.includes('?') ? '&' : '?') + 'ts=' + Date.now();

          teardownPlayer({ keepVideo: false });
          player = createPlayer();

          player.on(E.STREAM_INITIALIZED, () => {
            hideOffline();
            const pr = video.play?.();
            if (pr?.catch) pr.catch(() => {});
            setStatus('ok', 'Playing live stream');
          });

          player.on(E.ERROR, (e) => {
            const http = e?.event?.status || e?.status || 0;
            if (http === 0 || http === 404 || http === 403 || (http >= 500 && http < 600)) {
              setStatus('warn', spinner(`Player error (${http || 'net'}) — rechecking`));
              teardownPlayer({ keepVideo: false });
              startPolling();
            }
          });

          try {
            player.initialize(video, null, true);
            player.attachSource(src);
          } catch {
            cloneVideoElement();
            player = createPlayer();
            player.initialize(video, null, true);
            player.attachSource(src);
          }
        }

        function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

        function startPolling() {
          if (polling) return;
          polling = true;
          consecutiveOK = 0;
          showOffline();

          const tick = async () => {
            const url = MPD_URL + (MPD_URL.includes('?') ? '&' : '?') + 'check=' + Date.now();
            const res = await headOrGet(url);

            if (res.ok) {
              consecutiveOK += 1;
              setStatus('info', spinner(`MPD OK (${consecutiveOK}/2)…`));
              if (consecutiveOK >= 2) {
                await delay(500); // grace: let first segments show up
                clearTimeout(pollTimer); pollTimer = null;
                polling = false;
                setStatus('ok', 'Manifest available — starting');
                initPlayer();
                return;
              }
            } else {
              consecutiveOK = 0;
              const code = res.status || 'net';
              setStatus('warn', spinner(`Waiting for MPD (status: ${code})…`));
            }

            pollTimer = setTimeout(tick, 1000);
          };

          setStatus('info', spinner('Checking MPD…'));
          tick();
        }

        // Simple live stall watchdog
        let lastTime = 0, stall = 0;
        setInterval(() => {
          try {
            const now = video.currentTime || 0;
            if (Math.abs(now - lastTime) < 0.05) stall += 1; else stall = 0;
            lastTime = now;
            if (stall >= 5 && player?.isDynamic?.()) {
              const live = player.duration?.();
              if (!isNaN(live)) {
                video.currentTime = Math.max(0, live - 0.5);
                stall = 0;
              }
            }
          } catch {}
        }, 1000);

        function updateStats() {
          try {
            const isLive = player?.isDynamic?.() || false;
            const liveEdge = isLive ? player?.duration?.() : NaN;
            const t = video.currentTime || 0;
            const latency = isLive && !isNaN(liveEdge) ? Math.max(0, liveEdge - t) : 0;
            const buffered = (video.buffered?.length ? video.buffered.end(video.buffered.length - 1) - t : 0) || 0;
            statsEl.textContent = `Latency: ${latency.toFixed(2)}s · Buffered: ${buffered.toFixed(2)}s`;
          } catch {}
          requestAnimationFrame(updateStats);
        }
        updateStats();

        // Start up
        setStatus('info', spinner('Initializing…'));
        startPolling();
      });
    </script>
  </body>
</html>
